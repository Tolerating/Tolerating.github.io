<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vue2.0学习(二)---计算属性和监听属性</title>
    <url>/2019/12/03/vue2.0/Vue-Study2/</url>
    <content><![CDATA[<blockquote>
<p>目录</p>
</blockquote>
<p>[TOC]</p>
<h1 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性(computed)"></a>计算属性(computed)</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Orginal message:"&#123;&#123;message&#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message:"&#123;&#123;reversedMessage&#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	el:&quot;#example&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	data:&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		message:&quot;hello&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	computed:&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		reversedMessage:function()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#x2F;&#x2F;&#39;this&#39;指向vm实例</span></pre></td></tr><tr><td class="code"><pre><span class="line">			return this.message.split(&#39;&#39;),reverse().join();</span></pre></td></tr><tr><td class="code"><pre><span class="line">			</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#x2F;&#x2F;该方法的执行依赖于this.message的值是否发生改版,这里不能设置message的值,</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#x2F;&#x2F;例如:this.message&#x3D;&quot;改变了&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#x2F;&#x2F;但是获得message的值并进行一些操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;data中的message的值一旦发生改变,计算属性(computed)中的reversedMessage方法就会执行</span></pre></td></tr></table></figure>



<h2 id="计算属性与方法"><a href="#计算属性与方法" class="headerlink" title="计算属性与方法"></a>计算属性与方法</h2><ol>
<li><p>计算属性是基于他们的依赖关系进行缓存的,只有在依赖关系发生改变时他们才能更新变化。这意味着只要message没有发生变化,多次访问reverseMessage计算属性会立即返回之前的缓存结果，而不必再次执行函数,但是计算属性在页面渲染后就会执行一次</p>
</li>
<li><p>方法总会在每次触发重新渲染时调用函数</p>
</li>
</ol>
<h2 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h2><p>computed 属性默认只有get,不过在需要是也可以提供一个set<br>博主个人理解:计算属性可以有多个依赖属性</p>
<ul>
<li>get: 获取依赖的属性值</li>
<li>set:设置依赖的属性值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;部分代码</span></pre></td></tr><tr><td class="code"><pre><span class="line">computed:&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	num2:&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		get:function()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			return this.num-1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		set:function(val)&#123;		&#x2F;&#x2F;接收设置的值,这里的val是一个形参,可以自己设置成别的</span></pre></td></tr><tr><td class="code"><pre><span class="line">			this.num &#x3D; val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">vm.num &#x3D; 111;          &#x2F;&#x2F;这里会先执行set函数进行赋值,然后再执行get函数,结果为110</span></pre></td></tr><tr><td class="code"><pre><span class="line">注意:set函数肯定是给其依赖的属性赋值</span></pre></td></tr></table></figure>


<h1 id="侦听属性-watch"><a href="#侦听属性-watch" class="headerlink" title="侦听属性(watch)"></a>侦听属性(watch)</h1><p>通过watch来响应数据的变化,适用于异步加载数据或开销较大的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  el:&quot;#test&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  data:&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   name:&quot;lk&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">   user:&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      id:1001,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      name:&quot;刘凯&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      age:23,</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  watch:&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     name:function(newValue,oldValue)&#123;              &#x2F;&#x2F;监视name属性</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(&quot;修改之前的值:&quot; + newValue,&quot;修改之后的值:&quot; + oldValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">     user:&#123;                     &#x2F;&#x2F;监视user对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">      handler:function(newValue,oldValue)&#123;     &#x2F;&#x2F;注意这里的两个参数是对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F;由于user是一个对象,是按引用访问的,所以这里的newValue和oldValue是两个对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(&quot;修改之前的值:&quot; + newValue.name,&quot;修改之后的值:&quot; + oldValue.name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      deep:true        &#x2F;&#x2F;用来检测对象内部的属性变化,如果不加就是监测对象引用地址的改变</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注意:此用法不能监视对象里具体的一个属性</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;如果监视的是一个对象的话,那么回调函数里的参数就是监视的对象了</span></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js2.0学习(一)——基础</title>
    <url>/2019/12/02/vue2.0/Vue-Study1/</url>
    <content><![CDATA[<p>vue.js是一套构建用户界面的渐进式框架。<br><code>Vue</code>只关注视图层，采用自底向上增量开发的设计。<br><code>Vue</code> 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<a id="more"></a>

<h1 id="Vue语法格式"><a href="#Vue语法格式" class="headerlink" title="Vue语法格式"></a><code>Vue</code>语法格式</h1><h2 id="基本格式："><a href="#基本格式：" class="headerlink" title="基本格式："></a>基本格式：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;选项</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>实例:</p>
<pre><code>&lt;div id=&quot;vue_det&quot;&gt;
       &lt;h1&gt;site : {{site}}&lt;/h1&gt;
       &lt;h1&gt;url : {{url}}&lt;/h1&gt;
       &lt;h1&gt;{{details()}}&lt;/h1&gt;
   &lt;/div&gt;
   &lt;script type=&quot;text/javascript&quot;&gt;
       var vm = new Vue({
           el: &apos;#vue_det&apos;,
           data: {
               site: &quot;菜鸟教程&quot;,
               url: &quot;www.runoob.com&quot;,
               alexa: &quot;10000&quot;,
           },
           methods: {
               details: function() {
                   return  this.site + &quot; - 学的不仅是技术，更是梦想！&quot;;
               }
           }
       })
   &lt;/script&gt;</code></pre><ol>
<li><code>el(element)</code>参数是<code>DOM</code>元素中的<code>id</code>。</li>
<li><code>data</code>用于定义属性(也可以是实例外部方法(函数)的返回值),<code>v-model</code>双向绑定时,<code>data</code>中的属性若为空的话可以用双引号[“”],会根据绑定的数据类型自动转换类型。</li>
<li><code>methods</code>用于定义函数,通过<code>return</code>来返回函数值。</li>
</ol>
<h2 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h2><pre><code>var data = { site: &quot;菜鸟教程&quot;, url: &quot;www.runoob.com&quot;, alexa: 10000}
var vm = new Vue({
    el: &apos;#vue_det&apos;,
    data: data
})</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它们引用相同的对象！</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(vm.site === data.site) <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 设置属性也会影响到原始数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">vm.site = <span class="string">"Runoob"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(data.site + <span class="string">"&lt;br&gt;"</span>) <span class="comment">// Runoob</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// ……反之亦然</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">data.alexa = <span class="number">1234</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(vm.alexa) <span class="comment">// 1234</span></span></pre></td></tr></table></figure>



<p><code>vue</code>实例还提供了一些有用的实例属性与方法.它们都有前缀$.以便与用户定义的属性区分开来</p>
<p>例如:</p>
<pre><code>//我们的数据对象
var data = { site: &quot;菜鸟教程&quot;, url: &quot;www.runoob.com&quot;, alexa: 10000}
var vm = new Vue({
    el: &apos;#vue_det&apos;,
    data: data
})

document.write(vm.$data === data) // true
document.write(&quot;&lt;br&gt;&quot;) // true
document.write(vm.$el === document.getElementById(&apos;vue_det&apos;)) // true</code></pre><h1 id="Vue-js模板语法"><a href="#Vue-js模板语法" class="headerlink" title="Vue.js模板语法"></a>Vue.js模板语法</h1><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><ul>
<li>文本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id&#x3D;&quot;app&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	el:#app,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	data:&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		message:&quot;hello world!&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>






<pre><code>     使用这种方法可能会出现闪烁问题,即页面中的DOM和数据还没有加载完成,页面上会显示出大括号
解决:</code></pre><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[v-cloak]</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">display</span>:none;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在使用了双大括号语法的标签里使用v-cloak</p>
<p>扩展: v-text<br>文本插值,其等同于Mustache语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p v-text&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;p&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;!--和下面的一样--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;p&gt;&lt;&#123;&#123;msg&#125;&#125;&#x2F;p&gt;</span></pre></td></tr></table></figure>


<p>​<br> 2.  使用<code>v-once</code>指令,可以一次性的插值,当数据改变时,插值处的内容不会更新</p>
<ul>
<li>Html</li>
</ul>
<p>使用v-html指令用于输出html代码</p>
<pre><code> &lt;div id=&quot;app&quot;&gt;
    &lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    new Vue({
        el: &apos;#app&apos;,
        data: {
            message: &apos;&lt;h1&gt;菜鸟教程&lt;/h1&gt;&apos;
        }
    })
&lt;/script&gt;</code></pre><ul>
<li><p>属性</p>
<p>HTML属性中的值应使用v-bind指令(双大括号不能作用在HTML特性上)</p>
<p><code>&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</code>    </p>
<p>在布尔特性的情况下,它们的存在即暗示为true,  如果 <code>isButtonDisabled</code> 的值为 null ,<br><code>underfined</code>或 false,则disable的特性不会被包含在渲染出来的<code>&lt;button&gt;</code>元素中<br>(即不加载这个特性)</p>
</li>
<li><p>使用JavaScript表达式</p>
<p>vue.js支持JavaScript表达式(每个绑定都只能包含单个表达式)</p>
<p>JS表达式: 是由运算元和运算符(可选)构成，并产生运算结果的语法结构。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>数学运算:&#123;&#123;x+y&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>三目运算符:&#123;&#123;ok?"yes":"no"&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>方法的调用&#123;&#123;msg.split(""),reverse().join()&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr></table></figure>

<ul>
<li>指令</li>
</ul>
<p>指令是带有 v-前缀的特殊属性<br>    指令用于在表达式的值改变时,将某些行为应用到DOM上</p>
<p>例如 v-if v-bind  v-text……</p>
<ul>
<li>参数</li>
</ul>
<p>参数在指令后以冒号指明.<br>    例如 <code>v-bind:href = &quot;url&quot;</code></p>
<p>这里的<code>href</code>是参数,告知 <code>v-bind</code>指令该元素的<code>href</code>属性与表达式url的值绑定</p>
<p>参数除了是HTML元素的属性,也可以是监听的事件名,如<code>:click</code>事件</p>
<ul>
<li><p>修饰符</p>
<p>修饰符是以半角句号 <code>.</code> 指明的特殊后缀,用于指出一个指令应该以特殊方式绑定</p>
<p>例如: <code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;</code></p>
<pre><code>`.prevent` 修饰符告诉 v-on 指令对于触发的事件调用`event.preventDefault()`</code></pre></li>
<li><p>用户输入</p>
<pre><code>使用 v-model 指令来实现双向数据绑定</code></pre></li>
</ul>
<p>实例:      </p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
       &lt;p&gt;{{ message }}&lt;/p&gt;
       &lt;input v-model=&quot;message&quot;&gt;
   &lt;/div&gt;
   &lt;script&gt;
    new Vue({
        el: &apos;#app&apos;,
       data: {
         message: &apos;Runoob!&apos;
       }
     })
   &lt;/script&gt;</code></pre><p>按钮的事件可以使用 <code>v-on</code> 监听事件     例如:<code>v-on:click = &quot;click&quot;</code></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
