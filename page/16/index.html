<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta name="baidu-site-verification" content="code-3AeT0sTy6n"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="前端"><meta name="description" content="登高必自卑，行远必自迩。"><meta property="og:type" content="website"><meta property="og:title" content="前端菜鸟"><meta property="og:url" content="http:&#x2F;&#x2F;www.friendk.cn&#x2F;page&#x2F;16&#x2F;index.html"><meta property="og:site_name" content="前端菜鸟"><meta property="og:description" content="登高必自卑，行远必自迩。"><meta property="og:locale" content="zh-Hans"><meta name="twitter:card" content="summary"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.friendk.cn/page/16/"><script>let win = window.navigator.userAgent.toLowerCase();
	if(/mobi|android|touch|mini/i.test(win)){
		console.log(win);
	}else{
		(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/50da685b.js","daovoice")
		daovoice('init', {
		   app_id: "50da685b"
		});
		daovoice('update');
	}</script><title>前端菜鸟 - 登高必自卑，行远必自迩。</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">前端菜鸟</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description"></h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:void(0);" target="" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.friendk.cn/%E5%89%8D%E7%AB%AF/Ecmascript6/11%E3%80%81Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘凯"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="前端菜鸟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/%E5%89%8D%E7%AB%AF/Ecmascript6/11%E3%80%81Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" itemprop="url">ECMAScript6--Set和Map数据结构</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-22T17:30:00+08:00">2019-10-22 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">前端学习</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/ECMAScript6/" itemprop="url" rel="index"><span itemprop="name">ECMAScript6</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">3.2k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">13</span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>Set</code>数据结构类似于数组,但是成员的值都是唯一的，没有重复的值。<br><code>Set</code>本身是一个构造函数,用来生成<code>Set</code>数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">console</span>.log(i);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 2 3 5 4</span></span></code><br></pre></td></tr></table></figure><p>Set函数可以接受一个数组（或者具有 <code>iterable</code> 接口的其他数据结构）作为参数，用来初始化。</p><p><strong>注意:</strong></p><ul><li>向 <code>Set</code> 加入值的时候，不会发生类型转换,所以 5 和 ‘5’是两个不同的值</li><li>Set内部,<code>NaN</code>是等于自身的</li><li>两个对象总是不相等的(空对象除外)</li></ul><h2 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。</li><li><code>Set.prototype.size</code>：返回Set实例的成员总数。</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）</p><h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法:"></a>操作方法:</h4><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法:"></a>遍历方法:</h4><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><blockquote><p>需要注意的是:Set的遍历顺序就是插入顺序</p></blockquote><p><strong>keys , values , entries</strong></p><p>keys() , values() , entries() 返回的都是遍历器对象<br>由于Set结构没有键名,只有键值(或者说键名和键值是同一个值),所以keys和values方法的行为完全一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">//Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values <span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//可以省略values方法，直接用for...of循环遍历 Set。</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">for (let x of <span class="keyword">set</span>) &#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">console</span>.log(x);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// red</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// green</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// blue</span></span></code><br></pre></td></tr></table></figure><p><strong>foreach</strong></p><p><code>foreach</code>接收两个参数:</p><ul><li>一: 函数, 函数接收三个参数 键值(values) , 键名(keys) , 集合本身</li><li>二:表示绑定处理函数内部的this对象</li></ul><h4 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">//扩展运算符（...）内部使用for...of循环，可以用于 Set 结构。</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span></code><br><code class="highlight javascript"><span class="line">let arr = [...<span class="keyword">set</span>];</span></code><br><code class="highlight javascript"><span class="line">// ['red', 'green', 'blue']</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">//数组的map和filter方法也可以间接用于 Set </span></code><br><code class="highlight javascript"><span class="line">let <span class="keyword">set</span> = new Set([1, 2, 3]);</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].map(x =&gt; x * 2));</span></code><br><code class="highlight javascript"><span class="line">// 返回Set结构：&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 5]);</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].filter(x =&gt; (x % 2) == 0));</span></code><br><code class="highlight javascript"><span class="line">// 返回Set结构：&#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span></code><br></pre></td></tr></table></figure><p>在遍历操作中，同步改变原来的 <code>Set</code> 结构，有两种方法。一种是利用原 <code>Set</code> 结构映射出一个新的结构，然后赋值给原来的<code>Set</code> 结构；另一种是利用<code>Array.from</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line">/ 方法一</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].map(val =&gt; val * 2));</span></code><br><code class="highlight javascript"><span class="line">// <span class="keyword">set</span>的值是2, 4, 6</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">// 方法二</span></code><br><code class="highlight javascript"><span class="line">let <span class="keyword">set</span> = new Set([1, 2, 3]);</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">set</span> = new Set(Array.from(<span class="keyword">set</span>, val =&gt; val * 2));</span></code><br><code class="highlight javascript"><span class="line">// <span class="keyword">set</span>的值是2, 4, 6</span></code><br></pre></td></tr></table></figure><h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><p><code>WeakSet</code>与<code>Set</code>类似,也是不重复的值的集合。但是，它与 Set 有两个区别。<br>首先，<code>WeakSet</code> 的成员只能是对象，而不能是其他类型的值。<br>向<code>WeakSet</code>中放入对象以外的值会报错:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span></code><br><code class="highlight javascript"><span class="line">ws.add(<span class="number">1</span>)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span></code><br><code class="highlight javascript"><span class="line">ws.add(<span class="built_in">Symbol</span>())</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span></code><br></pre></td></tr></table></figure><p>其次，<code>WeakSet</code> 中的对象都是弱引用，即垃圾回收机制不考虑 <code>WeakSet</code>对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code>之中。</p><p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0,垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。<code>WeakSet</code>里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，<code>WeakSet</code>适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在<code>WeakSet</code>里面的引用就会自动消失。</p><p>由于上面这个特点，<code>WeakSet</code>的成员是不适合引用的，因为它会随时消失。另外，由于 <code>WeakSet</code>内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定<code>WeakSet</code>不可遍历。</p><blockquote><p>这些特点同样适用于 <code>WeakMap</code> 结构。</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>WeakSet</code>是一个构造函数,可以使用new命令,创建<code>WeakSet</code>数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span></code><br></pre></td></tr></table></figure><p>作为构造函数，<code>WeakSet</code> 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 <code>Iterable</code> 接口的对象，都可以作为 <code>WeakSet</code> 的参数。）该数组的所有成员，都会自动成为 <code>WeakSet</code>实例对象的成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span></code><br></pre></td></tr></table></figure><p>作为构造函数，<code>WeakSet</code> 可以接受一个数组或类似数组的对象(成员也要是对象)作为参数(实际上，任何具有 <code>Iterable</code>接口的对象，都可以作为 <code>WeakSet</code> 的参数。）该数组的所有成员，都会自动成为 <code>WeakSet</code> 实例对象的成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span></code><br></pre></td></tr></table></figure><blockquote><p>注意: 数组或类似数组的对象参数中的成员也要是对象</p></blockquote><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ul><li><code>WeakSet.prototype.add(value)</code>：向 <code>WeakSet</code>实例添加一个新成员。</li><li><code>WeakSet.prototype.delete(value)</code>：清除 <code>WeakSet</code>实例的指定成员。</li><li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值，表示某个值是否在</li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><p>Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><p>Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span></code><br><code class="highlight javascript"><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span></code><br><code class="highlight javascript"><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span></code><br><code class="highlight javascript"><span class="line">]);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">map.size <span class="comment">// 2</span></span></code><br><code class="highlight javascript"><span class="line">map.has(<span class="string">'name'</span>) <span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line">map.get(<span class="string">'name'</span>) <span class="comment">// "张三"</span></span></code><br><code class="highlight javascript"><span class="line">map.has(<span class="string">'title'</span>) <span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line">map.get(<span class="string">'title'</span>) <span class="comment">// "Author"</span></span></code><br></pre></td></tr></table></figure><p>Map构造函数接受数组作为参数，实际上执行的是下面的算法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> items = [</span></code><br><code class="highlight javascript"><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span></code><br><code class="highlight javascript"><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span></code><br><code class="highlight javascript"><span class="line">];</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">items.forEach(</span></code><br><code class="highlight javascript"><span class="line">  ([key, value]) =&gt; map.set(key, value)</span></code><br><code class="highlight javascript"><span class="line">);</span></code><br></pre></td></tr></table></figure><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的Map.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([</span></code><br><code class="highlight javascript"><span class="line">  ['foo', 1],</span></code><br><code class="highlight javascript"><span class="line">  ['bar', 2]</span></code><br><code class="highlight javascript"><span class="line">]);</span></code><br><code class="highlight javascript"><span class="line">const m1 = new Map(<span class="keyword">set</span>);</span></code><br><code class="highlight javascript"><span class="line">m1.<span class="keyword">get</span>('foo') // 1</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">const m2 = new Map([['baz', 3]]);</span></code><br><code class="highlight javascript"><span class="line">const m3 = new Map(m2);</span></code><br><code class="highlight javascript"><span class="line">m3.<span class="keyword">get</span>('baz') // 3</span></code><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p></li><li><p>如果读取一个未知的键，则返回<code>undefined</code></p></li><li><p>只有对同一个对象的引用，<code>Map</code> 结构才将其视为同一个键。<br><code>Map</code> 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。比如连个数组的值虽然相同,但是他们的内存地址不同,就是不同的键<br>如果 <code>Map</code>的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，<code>Map</code> 将其视为一个键<code>undefined</code>和<code>null</code>是两个不同的键</p><p>虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p></li></ul><h2 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h2><ol><li><p>size</p><p>返回 Map 结构的成员总数</p></li><li><p>Map.prototype.set(key, value)</p><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个<code>Map</code> 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p></li><li><p>Map.prototype.get(key)</p><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p></li><li><p>Map.prototype.has(key)</p><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p></li><li><p>Map.prototype.delete(key)<br><code>delete</code>方法删除某个键，返回true。如果删除失败，返回false。</p></li><li><p>Map.prototype.clear()</p><p><code>clear</code>方法清除所有成员，没有返回值。</p></li></ol><h2 id="遍历方法-1"><a href="#遍历方法-1" class="headerlink" title="遍历方法"></a>遍历方法</h2><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li>​ <code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li>​ <code>Map.prototype.values()</code>：返回键值的遍历器。</li><li>​ <code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li>​ <code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><blockquote><p>注意: Map 的遍历顺序就是插入顺序</p></blockquote><p><code>foreach</code>接收两个参数:</p><ul><li>一: 函数, 函数接收三个参数 键值(values) , 键名(keys) , 集合本身 (map)</li><li>二:表示绑定处理函数内部的this对象</li></ul><h2 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h2><h3 id="Map转为数组"><a href="#Map转为数组" class="headerlink" title="Map转为数组"></a>Map转为数组</h3><p>Map 转为数组最方便的方法，就是使用扩展运算符( … )</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span></code><br><code class="highlight javascript"><span class="line">  .set(<span class="literal">true</span>, <span class="number">7</span>)</span></code><br><code class="highlight javascript"><span class="line">  .set(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">'abc'</span>]);</span></code><br><code class="highlight javascript"><span class="line">[...myMap]</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ]</span></span></code><br></pre></td></tr></table></figure><h3 id="数组转为Map"><a href="#数组转为Map" class="headerlink" title="数组转为Map"></a>数组转为Map</h3><p>将数组传入 Map 构造函数，就可以转为 Map。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([</span></code><br><code class="highlight javascript"><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span></code><br><code class="highlight javascript"><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">'abc'</span>]]</span></code><br><code class="highlight javascript"><span class="line">])</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// Map &#123;</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//   true =&gt; 7,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; ['abc']</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#125;</span></span></code><br></pre></td></tr></table></figure><h3 id="Map转为对象"><a href="#Map转为对象" class="headerlink" title="Map转为对象"></a>Map转为对象</h3><p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p><p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span></code><br><code class="highlight javascript"><span class="line">    obj[k] = v;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> obj;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span></code><br><code class="highlight javascript"><span class="line">  .set(<span class="string">'yes'</span>, <span class="literal">true</span>)</span></code><br><code class="highlight javascript"><span class="line">  .set(<span class="string">'no'</span>, <span class="literal">false</span>);</span></code><br><code class="highlight javascript"><span class="line">strMapToObj(myMap)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span></code><br></pre></td></tr></table></figure><h3 id="对象转为Map"><a href="#对象转为Map" class="headerlink" title="对象转为Map"></a>对象转为Map</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span></code><br><code class="highlight javascript"><span class="line">    strMap.set(k, obj[k]);</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> strMap;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">objToStrMap(&#123;<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// Map &#123;"yes" =&gt; true, "no" =&gt; false&#125;</span></span></code><br></pre></td></tr></table></figure><h3 id="Map转为JSON"><a href="#Map转为JSON" class="headerlink" title="Map转为JSON"></a>Map转为JSON</h3><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'yes'</span>, <span class="literal">true</span>).set(<span class="string">'no'</span>, <span class="literal">false</span>);</span></code><br><code class="highlight javascript"><span class="line">strMapToJson(myMap)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// '&#123;"yes":true,"no":false&#125;'</span></span></code><br></pre></td></tr></table></figure><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJson</span>(<span class="params">map</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="literal">true</span>, <span class="number">7</span>).set(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">'abc'</span>]);</span></code><br><code class="highlight javascript"><span class="line">mapToArrayJson(myMap)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span></span></code><br></pre></td></tr></table></figure><h3 id="JSON转为Map"><a href="#JSON转为Map" class="headerlink" title="JSON转为Map"></a>JSON转为Map</h3><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> objToStrMap(<span class="built_in">JSON</span>.parse(jsonStr));</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">jsonToStrMap(<span class="string">'&#123;"yes": true, "no": false&#125;'</span>)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125;</span></span></code><br></pre></td></tr></table></figure><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">JSON</span>.parse(jsonStr));</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">jsonToMap(<span class="string">'[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span>)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125;</span></span></code><br></pre></td></tr></table></figure><h1 id="WeakWap"><a href="#WeakWap" class="headerlink" title="WeakWap"></a>WeakWap</h1><p><code>WeakWap</code>结构与<code>Wap</code>结构类似,也是用于生成键值对的集合。</p><p><code>WeakWap与Wap</code>的区别:</p><ul><li><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</li><li><code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</li></ul><p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。<br>注意，<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用</p><h2 id="WeakMap语法"><a href="#WeakMap语法" class="headerlink" title="WeakMap语法"></a>WeakMap语法</h2><p><code>WeakMap</code>没有遍历操作和size属性,只有以下四个方法可用:</p><ul><li><code>get()</code></li><li><code>set()</code></li><li><code>has()</code></li><li><code>delete()</code></li></ul><h2 id="WeakMap的用途"><a href="#WeakMap的用途" class="headerlink" title="WeakMap的用途"></a>WeakMap的用途</h2><p><code>WeakMap</code> 应用的典型场合就是 DOM 节点作为键名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>);</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">myWeakmap.set(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">myElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(myElement);</span></code><br><code class="highlight javascript"><span class="line">  logoData.timesClicked++;</span></code><br><code class="highlight javascript"><span class="line">&#125;, <span class="literal">false</span>);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">/*myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</span></span></code><br></pre></td></tr></table></figure><p><code>WeakMap</code>的另一个用处是部署私有属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); </span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">constructor</span>(counter, action) &#123;</span></code><br><code class="highlight javascript"><span class="line">    _counter.set(<span class="keyword">this</span>, counter);</span></code><br><code class="highlight javascript"><span class="line">    _action.set(<span class="keyword">this</span>, action);</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">  dec() &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">let</span> counter = _counter.get(<span class="keyword">this</span>);</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span></code><br><code class="highlight javascript"><span class="line">    counter--;</span></code><br><code class="highlight javascript"><span class="line">    _counter.set(<span class="keyword">this</span>, counter);</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span></code><br><code class="highlight javascript"><span class="line">      _action.get(<span class="keyword">this</span>)();</span></code><br><code class="highlight javascript"><span class="line">    &#125;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Countdown(<span class="number">2</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'DONE'</span>));</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">c.dec()</span></code><br><code class="highlight javascript"><span class="line">c.dec()</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// DONE</span></span></code><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.friendk.cn/%E5%89%8D%E7%AB%AF/Ecmascript6/10%E3%80%81Symbol.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘凯"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="前端菜鸟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/%E5%89%8D%E7%AB%AF/Ecmascript6/10%E3%80%81Symbol.html" itemprop="url">ECMAScript6--Symbol</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-21T17:30:00+08:00">2019-10-21 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">前端学习</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/ECMAScript6/" itemprop="url" rel="index"><span itemprop="name">ECMAScript6</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">2.6k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">11</span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><p><code>ES5</code>的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。</p><p><code>Symbol</code>表示独一无二的值</p><p><code>Symbol</code>值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的<code>Symbol</code> 类型。凡是属性名属于 <code>Symbol</code>类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">typeof</span> s</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// "symbol"</span></span></code><br></pre></td></tr></table></figure><blockquote><p>注意：Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象，也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的原始数据类型。</p></blockquote><p>Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">s1 <span class="comment">// Symbol(foo)</span></span></code><br><code class="highlight javascript"><span class="line">s2 <span class="comment">// Symbol(bar)</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span></code><br><code class="highlight javascript"><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span></code><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>Symbol函数的参数只是表示对当前Symbol值得描述，因此相同参数的Symbol函数返回的返回值是不相等的</li><li>Symbol值不能与其它类型的值进行运算，会报错</li><li>Symbol值可以显示转为字符串，也可以转为布尔值</li></ul></blockquote><h1 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h1><p>通过该属性可以获取到<code>Symbol</code>的描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">sym.description <span class="comment">// "foo"</span></span></code><br></pre></td></tr></table></figure><h1 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h1><p><code>Symbol</code>作为属性名的用法:</p><ul><li>在对象的外部，通过方括号进行赋值，切记不能使用 . 符号赋值【因为点运算符后面总是字符串，所以不会读取<code>Symbol</code>实例作为标识所指代的那个值】</li><li>通过<code>object.defineProperty</code>赋值</li><li>在对象内部，<code>Symbol</code>值定义属性时，<code>Symbol</code>值必须放在方括号之中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 第一种写法</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span></code><br><code class="highlight javascript"><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 第二种写法</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> a = &#123;</span></code><br><code class="highlight javascript"><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 第三种写法</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span></code><br><code class="highlight javascript"><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span></code><br></pre></td></tr></table></figure><h1 id="魔术字符串"><a href="#魔术字符串" class="headerlink" title="魔术字符串"></a>魔术字符串</h1><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p><h1 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h1><p><code>Symbol</code>作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有<code>Symbol</code>属性名。</p><p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的<code>Symbol</code>值。</p><p><code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和<code>Symbol</code>键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span></code><br><code class="highlight javascript"><span class="line">  enum: <span class="number">2</span>,</span></code><br><code class="highlight javascript"><span class="line">  nonEnum: <span class="number">3</span></span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// [Symbol(my_key)]</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span></span></code><br></pre></td></tr></table></figure><h1 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h1><p>有时，我们希望重新使用同一个<code>Symbol</code>值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后所有有没有以该参数作为名称的Symbol值。如果有，就返回这个<code>Symbol</code>值，否则就新建并返回一个以该字符串为名称的<code>Symbol</code>值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">s1 === s2 <span class="comment">// true</span></span></code><br></pre></td></tr></table></figure><blockquote><p>注意：Symbol.for()与Symbol()这两种写法。都会生成新的Symbol。它们的区别就是，前者会被登记在全局环境中供搜索，后者不会。</p></blockquote><p><code>Symbol.keyFor</code>方法返回一个已登记的Symbol类型值的<code>key</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span></code><br></pre></td></tr></table></figure><blockquote><p>注意：Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的iframe或service work中取到同一个值</p></blockquote><h1 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h1><p>除了定义自己使用的 <code>Symbol</code>值以外，ES6 还提供了 11 个内置的 <code>Symbol</code>值，指向语言内部使用的方法。</p><h2 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h2><p>对象的<code>Symbol.hasInstance</code>属性,指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  [<span class="built_in">Symbol</span>.hasInstance](foo) &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> MyClass() <span class="comment">// true</span></span></code><br></pre></td></tr></table></figure><blockquote><p>上面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的Symbol.hasInstance方法，会在进行instanceof运算时自动调用，判断左侧的运算子是否为Array的实例。</p></blockquote><h2 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h2><p>对象<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值表示该对象用于<code>Array.prototype.concat()</code>时,是否可以展开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span></code><br><code class="highlight javascript"><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr1, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span></code><br><code class="highlight javascript"><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable] <span class="comment">// undefined</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span></code><br><code class="highlight javascript"><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span></code><br><code class="highlight javascript"><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr2, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', ['c','d'], 'e']</span></span></code><br></pre></td></tr></table></figure><blockquote><p>上面代码说明，数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开效果</p></blockquote><p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p><h2 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h2><p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创造衍生对象时，会使用该属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x);</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> c = a.filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span>);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">b <span class="keyword">instanceof</span> MyArray <span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line">c <span class="keyword">instanceof</span> MyArray <span class="comment">// true</span></span></code><br></pre></td></tr></table></figure><blockquote><p>上面代码中，子类MyArray继承了父类Array，a时MyArray的实例，b和c是a的衍生对象。虽然b和c都是调用数组方法生成的，但是实际上它们是MyArray的实例，而不是数组（Array）的实例</p></blockquote><p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//定义Symbol.species属性要采用get取值器。</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//默认的Symbol.species属性等同于下面的写法。</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br></pre></td></tr></table></figure><h2 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h2><p>对象<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">String</span>.prototype.match(regexp)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line">regexp[<span class="built_in">Symbol</span>.match](<span class="keyword">this</span>)</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMatcher</span> </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  [<span class="built_in">Symbol</span>.match](string) &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>.indexOf(string);</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="string">'e'</span>.match(<span class="keyword">new</span> MyMatcher()) <span class="comment">// 1</span></span></code><br></pre></td></tr></table></figure><h2 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h2><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">String</span>.prototype.replace(searchValue, replaceValue)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line">searchValue[<span class="built_in">Symbol</span>.replace](<span class="keyword">this</span>, replaceValue)</span></code><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> x = &#123;&#125;;</span></code><br><code class="highlight javascript"><span class="line">x[<span class="built_in">Symbol</span>.replace] = <span class="function">(<span class="params">...s</span>) =&gt;</span> <span class="built_in">console</span>.log(s);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="string">'Hello'</span>.replace(x, <span class="string">'World'</span>) <span class="comment">// ["Hello", "World"]</span></span></code><br></pre></td></tr></table></figure><p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p><h2 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h2><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">String</span>.prototype.search(regexp)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line">regexp[<span class="built_in">Symbol</span>.search](<span class="keyword">this</span>)</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySearch</span> </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">this</span>.value = value;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">  [<span class="built_in">Symbol</span>.search](string) &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> string.indexOf(<span class="keyword">this</span>.value);</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="string">'foobar'</span>.search(<span class="keyword">new</span> MySearch(<span class="string">'foo'</span>)) <span class="comment">// 0</span></span></code><br></pre></td></tr></table></figure><h2 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h2><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">String</span>.prototype.split(separator, limit)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line">separator[<span class="built_in">Symbol</span>.split](<span class="keyword">this</span>, limit)</span></code><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySplitter</span> </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">this</span>.value = value;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">  [<span class="built_in">Symbol</span>.split](string) &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">let</span> index = string.indexOf(<span class="keyword">this</span>.value);</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span></code><br><code class="highlight javascript"><span class="line">      <span class="keyword">return</span> string;</span></code><br><code class="highlight javascript"><span class="line">    &#125;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> [</span></code><br><code class="highlight javascript"><span class="line">      string.substr(<span class="number">0</span>, index),</span></code><br><code class="highlight javascript"><span class="line">      string.substr(index + <span class="keyword">this</span>.value.length)</span></code><br><code class="highlight javascript"><span class="line">    ];</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'foo'</span>))</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// ['', 'bar']</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'bar'</span>))</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// ['foo', '']</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'baz'</span>))</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 'foobar'</span></span></code><br></pre></td></tr></table></figure><blockquote><p>上面方法使用Symbol.split方法，重新定义了字符串对象的split方法的行为</p></blockquote><h2 id="Symbol-Iterator"><a href="#Symbol-Iterator" class="headerlink" title="Symbol.Iterator"></a>Symbol.Iterator</h2><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> myIterable = &#123;&#125;;</span></code><br><code class="highlight javascript"><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span></code><br></pre></td></tr></table></figure><h2 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h2><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p><p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p><ul><li><code>Number</code>：该场合需要转成数值</li><li><code>String</code>：该场合需要转成字符串</li><li><code>Default</code>：该场合可以转成数值，也可以转成字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">switch</span> (hint) &#123;</span></code><br><code class="highlight javascript"><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span></code><br><code class="highlight javascript"><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span></code><br><code class="highlight javascript"><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span></code><br><code class="highlight javascript"><span class="line">        <span class="keyword">return</span> <span class="string">'str'</span>;</span></code><br><code class="highlight javascript"><span class="line">      <span class="keyword">case</span> <span class="string">'default'</span>:</span></code><br><code class="highlight javascript"><span class="line">        <span class="keyword">return</span> <span class="string">'default'</span>;</span></code><br><code class="highlight javascript"><span class="line">      <span class="keyword">default</span>:</span></code><br><code class="highlight javascript"><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span></code><br><code class="highlight javascript"><span class="line">     &#125;</span></code><br><code class="highlight javascript"><span class="line">   &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="number">2</span> * obj <span class="comment">// 246</span></span></code><br><code class="highlight javascript"><span class="line"><span class="number">3</span> + obj <span class="comment">// '3default'</span></span></code><br><code class="highlight javascript"><span class="line">obj == <span class="string">'default'</span> <span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">String</span>(obj) <span class="comment">// 'str'</span></span></code><br></pre></td></tr></table></figure><h2 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h2><p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 例一</span></span></code><br><code class="highlight javascript"><span class="line">(&#123;[<span class="built_in">Symbol</span>.toStringTag]: <span class="string">'Foo'</span>&#125;.toString())</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// "[object Foo]"</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 例二</span></span></code><br><code class="highlight javascript"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">get</span> [Symbol.toStringTag]() &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> <span class="string">'xxx'</span>;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> Collection();</span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.prototype.toString.call(x) <span class="comment">// "[object xxx]"</span></span></code><br></pre></td></tr></table></figure><p>ES6 新增内置对象的Symbol.toStringTag属性值如下。</p><ul><li><code>JSON[Symbol.toStringTag]</code>：’JSON’</li><li><code>Math[Symbol.toStringTag]</code>：’Math’</li><li><code>Module 对象M[Symbol.toStringTag]</code>：’Module’</li><li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：’ArrayBuffer’</li><li><code>DataView.prototype[Symbol.toStringTag]</code>：’DataView’</li><li><code>Map.prototype[Symbol.toStringTag]</code>：’Map’</li><li><code>Promise.prototype[Symbol.toStringTag]</code>：’Promise’</li><li><code>Set.prototype[Symbol.toStringTag]</code>：’Set’</li><li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：’Uint8Array’等</li><li><code>WeakMap.prototype[Symbol.toStringTag]</code>：’WeakMap’</li><li><code>WeakSet.prototype[Symbol.toStringTag]</code>：’WeakSet’</li><li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：’Map Iterator’</li><li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：’Set Iterator’</li><li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：’String Iterator’</li><li><code>Symbol.prototype[Symbol.toStringTag]</code>：’Symbol’</li><li><code>Generator.prototype[Symbol.toStringTag]</code>：’Generator’</li><li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：’GeneratorFunction’</li></ul><h2 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h2><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被<code>with</code>环境排除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables]</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#123;</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//   copyWithin: true,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//   entries: true,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//   fill: true,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//   find: true,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//   findIndex: true,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//   includes: true,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//   keys: true</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#125;</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.keys(<span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables])</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">/* ['copyWithin', 'entries', 'fill', 'find', 'findIndex', </span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">	'includes', 'keys']</span></span></code><br></pre></td></tr></table></figure><p>上面代码说明，数组有7个属性，会被<code>with</code>命令排除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 没有 unscopables 时</span></span></code><br><code class="highlight javascript"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  foo() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span></code><br><code class="highlight javascript"><span class="line">  foo(); <span class="comment">// 1</span></span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 有 unscopables 时</span></span></code><br><code class="highlight javascript"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  foo() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">get</span> [Symbol.unscopables]() &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="literal">true</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span></code><br><code class="highlight javascript"><span class="line">  foo(); <span class="comment">// 2</span></span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br></pre></td></tr></table></figure><blockquote><p>上面代码通过指定Symbol.unscopables属性，使得with语法块不会在当前作用域寻找foo属性，即foo将指向外层作用域的变量。</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.friendk.cn/%E5%89%8D%E7%AB%AF/Ecmascript6/9%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘凯"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="前端菜鸟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/%E5%89%8D%E7%AB%AF/Ecmascript6/9%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html" itemprop="url">ECMAScript6--对象的扩展</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-20T16:30:00+08:00">2019-10-20 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">前端学习</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/ECMAScript6/" itemprop="url" rel="index"><span itemprop="name">ECMAScript6</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">4.4k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">18</span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h1 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h1><p>ES6允许直接写入变量和函数,作为对象的属性和方法.(这在之前是不允许的)<br>直接写入变量:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</span></code><br><code class="highlight javascript"><span class="line">baz <span class="comment">// &#123;foo: "bar"&#125;</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//当属性名与变量名相等时可以只写一个属性名</span></span></code><br></pre></td></tr></table></figure><p>方法的简写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> o = &#123;</span></code><br><code class="highlight javascript"><span class="line">  method() &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> o = &#123;</span></code><br><code class="highlight javascript"><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br></pre></td></tr></table></figure><p>如果某个方法的值是一个Generator函数,前面需要加上星号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  * m() &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">yield</span> <span class="string">'hello world'</span>;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br></pre></td></tr></table></figure><h1 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h1><p>JavaScript定义对象的属性:</p><ul><li>方法一: <code>obj.foo = true</code>;</li><li>方法二(属性名表达式): <code>obj[&#39;a&#39; + &#39;bc&#39;] = 123</code>;</li></ul><p>中括号中还可以放入变量名<br>ES6之前,使用字面量方式定义对象(使用大括号),只能使用方法一的形式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">var</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  foo: <span class="literal">true</span>,</span></code><br><code class="highlight javascript"><span class="line">  abc: <span class="number">123</span></span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br></pre></td></tr></table></figure><p>ES6允许字面量定义对象时,用方法二作为对象的属性名,即把表达式放在方括号内:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  [propKey]: <span class="literal">true</span>,</span></code><br><code class="highlight javascript"><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br></pre></td></tr></table></figure><p>使用方法二定义方法名:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">obj.hello() <span class="comment">// hi</span></span></code><br></pre></td></tr></table></figure><blockquote><p>注意:</p><ul><li>属性名表达式不能与简洁表达式同时使用</li><li>属性名表达式如果是一个对象,默认情况下会自动转为字符串[object,object],(会覆盖掉别的属性名表达式为对象的值)</li></ul></blockquote><h1 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h1><p>函数的name属性,返回函数名. 对象方法也是函数,因此也有name属性</p><p>如果对象的方法使用了取值函数(getter)和存值函数(setter),则name属性不是在该方法上面,而是该方法的属性的描述对象get和set属性上面,返回值是方法名前加上get和set</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">get</span> foo() &#123;&#125;,</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">set</span> foo(x) &#123;&#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">obj.foo.name</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// TypeError: Cannot read property 'name' of undefined</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">descriptor.get.name <span class="comment">// "get foo"</span></span></code><br><code class="highlight javascript"><span class="line">descriptor.set.name <span class="comment">// "set foo"</span></span></code><br></pre></td></tr></table></figure><p>特殊情况:</p><ul><li>bind方法创造的函数,name属性返回bound加上原函数的名字</li><li>Function构造函数创造的函数,name属性返回anonymous</li><li>如果对象的方法是一个Symbol,那么name属性返回的是这个Symbol值的描述</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> key1 = <span class="built_in">Symbol</span>(<span class="string">'description'</span>);</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> key2 = <span class="built_in">Symbol</span>();</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  [key1]() &#123;&#125;,</span></code><br><code class="highlight javascript"><span class="line">  [key2]() &#123;&#125;,</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line">obj[key1].name <span class="comment">// "[description]"</span></span></code><br><code class="highlight javascript"><span class="line">obj[key2].name <span class="comment">// ""</span></span></code><br></pre></td></tr></table></figure><h1 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h1><h2 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h2><p>对象的每个属性都有一个描述对象(Descriptor),用来控制该属性的行为.</p><p>ES5的<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象.</p><p>描述对象的enumerable属性,称为”可枚举性”,如果该属性为false,就表示某些操作会忽略当前属性</p><p>目前,有四个操作会忽略enumerable为false的属性:</p><ul><li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li><li><code>Object.assign()</code>： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</li></ul><p>上面四个方法中,只有for…in会返回继承的属性,其他三个方法都会忽略继承的属性,只处理对象自身的属性<br><strong>注意:</strong><br>所有 Class 的原型的方法都是不可枚举的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="class"><span class="keyword">class</span></span>&#123;foo()&#123;&#125;&#125;.prototype, <span class="string">'foo'</span>)</span></code><br><code class="highlight javascript"><span class="line">.enumerable</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// false</span></span></code><br></pre></td></tr></table></figure><h2 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h2><p>ES6一共有5中方法可以遍历对象的属性</p><h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</p><h3 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h3><p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><h3 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h3><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p><h3 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h3><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><h3 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h3><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。<br>以上的5种方法遍历对象的键名,都遵守同样的属性遍历的次序规则:</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></span></code><br></pre></td></tr></table></figure><h1 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h1><p>super关键字指向当前对象的原型对象</p><p><strong>注意:</strong><br>该关键字只有用在对象方法的简写法里面才有效,否则会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 报错</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//方法简写法</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> proto = &#123;</span></code><br><code class="highlight javascript"><span class="line">  foo: <span class="string">'hello'</span></span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  foo: <span class="string">'world'</span>,</span></code><br><code class="highlight javascript"><span class="line">  find() &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span></code><br><code class="highlight javascript"><span class="line">obj.find() <span class="comment">// "hello"</span></span></code><br></pre></td></tr></table></figure><h1 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h1><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>扩展运算符用于解构赋值,必须位于最后一个参数,会将所有为被读取的属性和值一起拷贝到新对象上面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line">x <span class="comment">// 1</span></span></code><br><code class="highlight javascript"><span class="line">y <span class="comment">// 2</span></span></code><br><code class="highlight javascript"><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span></code><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null,就会报错,因为它们无法转为对象</li><li>扩展运算符的解构赋值不能复制继承自原型的属性</li><li>解构赋值的拷贝是浅拷贝</li></ul><p>解构赋值还可以用于扩展某个函数的参数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="comment">// ...</span></span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="comment">// 使用 x 和 y 参数进行操作</span></span></code><br><code class="highlight javascript"><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> baseFunction(restConfig);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br></pre></td></tr></table></figure><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>对象的扩展运算符 ( … ) 用于取出参数对象的所有可遍历属性,拷贝到当前对象之中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span></code><br><code class="highlight javascript"><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span></code><br></pre></td></tr></table></figure><p>由于数组是特殊的对象,所以对象的扩展运算符也可以用于数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> foo = &#123; ...[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] &#125;;</span></code><br><code class="highlight javascript"><span class="line">foo</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#123;0: "a", 1: "b", 2: "c"&#125;</span></span></code><br></pre></td></tr></table></figure><p><strong>规则:</strong></p><ul><li>如果扩展运算符后面是一个空对象,则没有任何效果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line">&#123;...&#123;&#125;, <span class="attr">a</span>: <span class="number">1</span>&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#123; a: 1 &#125;</span></span></code><br></pre></td></tr></table></figure><ul><li>如果扩展运算符后面不是对象,则会自动将其转为对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 等同于 &#123;...Object(1)&#125;</span></span></code><br><code class="highlight javascript"><span class="line">&#123;..<span class="number">.1</span>&#125; <span class="comment">// &#123;&#125;</span></span></code><br></pre></td></tr></table></figure><ul><li>如果扩展运算符后面是字符串,它会自动转成一个类似数组的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line">&#123;...<span class="string">'hello'</span>&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#123;0: "h", 1: "e", 2: "l", 3: "l", 4: "o"&#125;</span></span></code><br></pre></td></tr></table></figure><p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 写法一</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> clone1 = &#123;</span></code><br><code class="highlight javascript"><span class="line">  __proto__: <span class="built_in">Object</span>.getPrototypeOf(obj),</span></code><br><code class="highlight javascript"><span class="line">  ...obj</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 写法二</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> clone2 = <span class="built_in">Object</span>.assign(</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj)),</span></code><br><code class="highlight javascript"><span class="line">  obj</span></code><br><code class="highlight javascript"><span class="line">);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 写法三</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> clone3 = <span class="built_in">Object</span>.create(</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span></code><br><code class="highlight javascript"><span class="line">)</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//推荐使用写法一和写法二</span></span></code><br></pre></td></tr></table></figure><p>扩展运算符等同于使用<code>Object.assign()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> aClone = &#123; ...a &#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> aClone = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span></code><br></pre></td></tr></table></figure><p>扩展运算符可以用于合并两个对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span></code><br></pre></td></tr></table></figure><p>注意:</p><ul><li>如果用户自定义的属性,放在扩展运算符后面,则扩展运算符内部的同名属性会被覆盖掉</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">x</span>:<span class="number">3</span>,<span class="attr">y</span>:<span class="number">4</span>&#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line">x    <span class="comment">//1</span></span></code><br><code class="highlight javascript"><span class="line">y    <span class="comment">//2</span></span></code><br></pre></td></tr></table></figure><ul><li>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</li><li>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  ...(x &gt; <span class="number">1</span> ? &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; : &#123;&#125;),</span></code><br><code class="highlight javascript"><span class="line">  b: <span class="number">2</span>,</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br></pre></td></tr></table></figure><p>​ <img src="https://qqadapt.qpic.cn/txdocpic/0/dc0f131b73a08bbf08b5e96faaf768e6/0" alt="img"></p><h1 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h1><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符 ( == ) 和严格相等运算符 ( === ) ,它们都有缺点，前者会自动转换数据类型,后者的<code>NaN</code>不等于自身,以及+0 等于 -0</p><p>JavaScript缺乏一种算法在所有环境中，只要两个值是一样的，它们就应该相等。<br>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<br><code>Object.is()</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// false</span></span></code><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>该方法中 +0不等于-0</li><li><code>NaN</code>等于自身</li></ul><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><p><code>Object.assign</code>方法用于对象的合并,将源对象（source）的所有可枚举属性，复制到目标对象（target）。<br><code>Object.assign</code>方法的第一个参数是目标对象,后面的所有参数都是源对象</p><ul><li>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li><li>如果只有一个参数,Object.assign方法会直接返回该参数</li><li>如果该参数不是对象，则会先转成对象，然后返回。</li><li>由于undefined和null无法转为对象,所以如果他们作为参数(首参数)会报错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">//首参数</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// 报错</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//非首参数</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//非对象作为非首参数传入时,这些参数都会转为对象,如果无法转为对象,就会跳过</span></span></code><br></pre></td></tr></table></figure><ul><li>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错,除了字符串会以数组的形式拷贝入对象,其他值都不会产生效果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> v1 = <span class="string">'abc'</span>;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> v2 = <span class="literal">true</span>;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> v3 = <span class="number">10</span>;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//Object(true) // &#123;[[PrimitiveValue]]: true&#125;</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//Object(10)  //  &#123;[[PrimitiveValue]]: 10&#125;</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//Object('abc')//&#123;0:"a",1:"b",2:"c",length:3,[[PrimitiveValue]]:"abc"&#125;</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//PrimitiveValue不可以被枚举</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//上面三种类型的值转换为包装对象后,只有字符串有可枚举的实义属性</span></span></code><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>浅拷贝: 如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">obj1.a.b = <span class="number">2</span>;</span></code><br><code class="highlight javascript"><span class="line">obj2.a.b <span class="comment">// 2</span></span></code><br></pre></td></tr></table></figure><ul><li>同名属性的替换: 目标对象与一个或多个源对象有同名属性时,后面的属性会覆盖前面的</li><li>数组的处理: <code>Object.assign</code>方法会把数组当作对象处理(数组的索引即为对象的属性名)</li><li>取值函数的处理:<code>Object.assign</code>方法只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> source = &#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">get</span> foo() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.assign(target, source)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span></code><br></pre></td></tr></table></figure><ul><li><code>Object.assign</code>方法拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性(<code>enumerable:false</code>)</li><li>属性名为 Symbol 值的属性，也会被<code>Object.assign()</code>拷贝</li></ul><h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p>1.为对象添加属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br></pre></td></tr></table></figure><p>2.为对象添加方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span></code><br><code class="highlight javascript"><span class="line">  someMethod(arg1, arg2) &#123;</span></code><br><code class="highlight javascript"><span class="line">    ···</span></code><br><code class="highlight javascript"><span class="line">  &#125;,</span></code><br><code class="highlight javascript"><span class="line">  anotherMethod() &#123;</span></code><br><code class="highlight javascript"><span class="line">    ···</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于下面的写法</span></span></code><br><code class="highlight javascript"><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  ···</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  ···</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br></pre></td></tr></table></figure><p>3.克隆对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br></pre></td></tr></table></figure><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p><p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br></pre></td></tr></table></figure><p>4.合并多个对象</p><p>将多个对象合并到某个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> merge =</span></code><br><code class="highlight javascript"><span class="line">  (target, ...sources) =&gt; <span class="built_in">Object</span>.assign(target, ...sources);</span></code><br></pre></td></tr></table></figure><p>5.为属性指定默认值</p><p>利用同名属性替换的特点,可以将默认值对象写在前面,后面跟源对象</p><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>ES5的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象(descriptor)<br>ES2017引入了<code>Object.getOwnPropertyDescriptors()</code>方法,返回指定对象所有自身属性(非继承属性)的描述对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj = &#123;</span></code><br><code class="highlight javascript"><span class="line">  foo: <span class="number">123</span>,</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">get</span> bar() &#123; <span class="keyword">return</span> <span class="string">'abc'</span> &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#123; foo:</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//    &#123; value: 123,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//      writable: true,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//      enumerable: true,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//      configurable: true &#125;,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//   bar:</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//      set: undefined,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//      enumerable: true,</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span></code><br></pre></td></tr></table></figure><p><strong>用处一:</strong></p><p>该方法的引入目的,主要是为了解决<code>Object.assign()</code>无法正确拷贝get属性和set属性的问题</p><p>使用<code>Object.getOwnPropertyDescriptor()</code>方法配合<code>Object.defineProperties()</code>方法,就可以实现正确拷贝:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="highlight plain"><span class="line">const source &#x3D; &#123;</span></code><br><code class="highlight plain"><span class="line">  set foo(value) &#123;</span></code><br><code class="highlight plain"><span class="line">    console.log(value);</span></code><br><code class="highlight plain"><span class="line">  &#125;</span></code><br><code class="highlight plain"><span class="line">&#125;;</span></code><br><code class="highlight plain"><span class="line">const target2 &#x3D; &#123;&#125;;</span></code><br><code class="highlight plain"><span class="line">Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));</span></code><br><code class="highlight plain"><span class="line">Object.getOwnPropertyDescriptor(target2, &#39;foo&#39;)</span></code><br><code class="highlight plain"><span class="line">&#x2F;&#x2F; &#123; get: undefined,</span></code><br><code class="highlight plain"><span class="line">&#x2F;&#x2F;   set: [Function: set foo],</span></code><br><code class="highlight plain"><span class="line">&#x2F;&#x2F;   enumerable: true,</span></code><br><code class="highlight plain"><span class="line">&#x2F;&#x2F;   configurable: true &#125;</span></code><br></pre></td></tr></table></figure><p>上面代码中,两个对象合并的逻辑可以写成一个函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> shallowMerge = <span class="function">(<span class="params">target, source</span>) =&gt;</span> <span class="built_in">Object</span>.defineProperties(</span></code><br><code class="highlight javascript"><span class="line">  target,</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(source)</span></code><br><code class="highlight javascript"><span class="line">);</span></code><br></pre></td></tr></table></figure><p><strong>用处二:</strong></p><p>配合<code>Object.create()</code>方法,将对象属性克隆到一个新对象(这属于浅拷贝).</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> clone = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj),</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 或者</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.create(</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span></code><br><code class="highlight javascript"><span class="line">);</span></code><br></pre></td></tr></table></figure><p><strong>用处三:</strong></p><p>实现一个对象继承另一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(</span></code><br><code class="highlight javascript"><span class="line">  prot,</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123;</span></code><br><code class="highlight javascript"><span class="line">    foo: <span class="number">123</span>,</span></code><br><code class="highlight javascript"><span class="line">  &#125;)</span></code><br><code class="highlight javascript"><span class="line">);</span></code><br></pre></td></tr></table></figure><p><strong>用处四:</strong></p><p><code>Object.getOwnPropertyDescriptors()</code>可以实现<code>Mixin</code>(混入)模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> mix = <span class="function">(<span class="params">object</span>) =&gt;</span> (&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">with</span>: <span class="function">(<span class="params">...mixins</span>) =&gt;</span> mixins.reduce(</span></code><br><code class="highlight javascript"><span class="line">    (c, mixin) =&gt; <span class="built_in">Object</span>.create(</span></code><br><code class="highlight javascript"><span class="line">      c, <span class="built_in">Object</span>.getOwnPropertyDescriptors(mixin)</span></code><br><code class="highlight javascript"><span class="line">    ), object)</span></code><br><code class="highlight javascript"><span class="line">&#125;);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// multiple mixins example</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="string">'a'</span>&#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">b</span>: <span class="string">'b'</span>&#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">'c'</span>&#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> d = mix(c).with(a, b);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">d.c <span class="comment">// "c"</span></span></code><br><code class="highlight javascript"><span class="line">d.b <span class="comment">// "b"</span></span></code><br><code class="highlight javascript"><span class="line">d.a <span class="comment">// "a"</span></span></code><br></pre></td></tr></table></figure><h2 id="proto-属性-Object-setPrototypeOf-Object-getPrototypeOf"><a href="#proto-属性-Object-setPrototypeOf-Object-getPrototypeOf" class="headerlink" title="_proto_属性,Object.setPrototypeOf(),Object.getPrototypeOf()"></a>_proto_属性,Object.setPrototypeOf(),Object.getPrototypeOf()</h2><h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><em>proto</em></h3><p>_proto_属性(前后各两个下划线),用来读取或设置当前对象的prototype对象,所有浏览器都部署了这个属性<br>ES6规定,只有浏览器必须部署这个属性,其他运行环境不一定需要部署,而且新的代码最好认为这个属性是不存在的. 因此最好不要使用这个属性.</p><p>用下面的方法代替:</p><ul><li><code>Object.setPrototypeOf()</code> (写操作)</li><li><code>Object.getPrototypeOf()</code> (读操作)</li><li><code>Object.create()</code> (生成操作)</li></ul><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法的作用于_proto_相同,用来设置一个对象的prototype对象,返回参数对象本身. 它是ES6正式推荐的设置原型对象的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 格式</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 用法</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//将proto对象设为obj对象的原型</span></span></code><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>如果第一个参数不是对象,会自动转为对象. 但是由于返回的还是第一个参数,所以这个操作不会产生任何效果:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="number">1</span>, &#123;&#125;) === <span class="number">1</span> <span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="string">'foo'</span>, &#123;&#125;) === <span class="string">'foo'</span> <span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">true</span>, &#123;&#125;) === <span class="literal">true</span> <span class="comment">// true</span></span></code><br></pre></td></tr></table></figure><ul><li>由于undefined和null无法转为对象,所以如果第一个参数是undefined或null,就会报错</li></ul><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>该方法与<code>Object.setPrototypeOf()</code>方法配套,用于读取一个对象的原型对象</p><p>用法: <code>Object.getPrototypeOf(obj)</code></p><p><strong>注意:</strong></p><ul><li>如果参数不是对象,会自动转为对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Number(1))</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(String('foo'))</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">'foo'</span>)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// String &#123;length: 0, [[PrimitiveValue]]: ""&#125;</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Boolean(true))</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">true</span>)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// Boolean &#123;[[PrimitiveValue]]: false&#125;</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>) === <span class="built_in">Number</span>.prototype <span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">'foo'</span>) === <span class="built_in">String</span>.prototype <span class="comment">// true</span></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">true</span>) === <span class="built_in">Boolean</span>.prototype <span class="comment">// true</span></span></code><br></pre></td></tr></table></figure><ul><li>如果参数是undefined或null,他们无法转为对象,所以报错.</li></ul><h2 id="Object-keys-Object-values-Object-entries"><a href="#Object-keys-Object-values-Object-entries" class="headerlink" title="Object.keys() , Object.values() , Object.entries()"></a>Object.keys() , Object.values() , Object.entries()</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>该方法返回一个数组,成员是参数对象自身的(不含继承的)所有可遍历属性的键名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.keys(obj)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// ["foo", "baz"]</span></span></code><br></pre></td></tr></table></figure><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p>该方法返回一个数组,成员是参数对象自身的(不含继承的)所有可遍历属性的键值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.values(obj)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// ["bar", 42]</span></span></code><br></pre></td></tr></table></figure><p>返回数组的成员顺序为:</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><p><strong>注意:</strong></p><ul><li><code>Object.values</code>只返回对象自身的可遍历属性[不是显示声明的属性默认是不可遍历的]</li><li><code>Object.values</code>会过滤属性名为Symbol值的属性</li><li>如果<code>Object.values</code>方法的参数是一个字符串,会返回各个字符组成的一个数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.values(<span class="string">'foo'</span>)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// ['f', 'o', 'o']</span></span></code><br></pre></td></tr></table></figure><ul><li>如果参数不是对象,<code>Object.values</code>会先将其转为对象,由于数值和布尔值的包装对象,都不会为实例添加非继承的属性,所以会返回空数组</li></ul><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p>该方法返回一个数组,成员是参数对象自身(不含继承的)所有可遍历属性的键值对数组<br>除了返回值不一样,该方法的行为与<code>Object.values</code>基本一致.</p><p><strong>用处一:</strong></p><p>将对象转为真正的Map结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span></code><br><code class="highlight javascript"><span class="line">map <span class="comment">// Map &#123; foo: "bar", baz: 42 &#125;</span></span></code><br></pre></td></tr></table></figure><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h2><p>该方法是<code>Object.entries()</code>的逆操作.用于将一个键值对数组转为对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.fromEntries([</span></code><br><code class="highlight javascript"><span class="line">  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span></code><br><code class="highlight javascript"><span class="line">  [<span class="string">'baz'</span>, <span class="number">42</span>]</span></code><br><code class="highlight javascript"><span class="line">])</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#123; foo: "bar", baz: 42 &#125;</span></span></code><br></pre></td></tr></table></figure><p>该方法的目的是将键值对的数据结构还原为对象,因此特别适合将Map结构转为对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 例一</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="built_in">Map</span>([</span></code><br><code class="highlight javascript"><span class="line">  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span></code><br><code class="highlight javascript"><span class="line">  [<span class="string">'baz'</span>, <span class="number">42</span>]</span></code><br><code class="highlight javascript"><span class="line">]);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.fromEntries(entries)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#123; foo: "bar", baz: 42 &#125;</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 例二</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'foo'</span>, <span class="literal">true</span>).set(<span class="string">'bar'</span>, <span class="literal">false</span>);</span></code><br><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.fromEntries(map)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#123; foo: true, bar: false &#125;</span></span></code><br></pre></td></tr></table></figure><p><strong>用处二:</strong></p><p>配合<code>URLSearchParams</code>对象,将查询字符串转为对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="built_in">Object</span>.fromEntries(<span class="keyword">new</span> URLSearchParams(<span class="string">'foo=bar&amp;baz=qux'</span>))</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// &#123; foo: "bar", baz: "qux" &#125;</span></span></code><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.friendk.cn/%E5%89%8D%E7%AB%AF/Ecmascript6/8%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘凯"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="前端菜鸟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/%E5%89%8D%E7%AB%AF/Ecmascript6/8%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html" itemprop="url">ECMAScript6--函数的扩展</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-18T13:30:00+08:00">2019-10-18 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">前端学习</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/ECMAScript6/" itemprop="url" rel="index"><span itemprop="name">ECMAScript6</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">2.8k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">10</span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h1 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6允许为函数的参数设置默认值,即直接写在参数定义的后面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">console</span>.log(x, y);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span></code><br><code class="highlight javascript"><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span></code><br><code class="highlight javascript"><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span></code><br></pre></td></tr></table></figure><p>注意:</p><ul><li>参数变量是默认声明的,不能用<code>let</code>或<code>const</code>再次声明,否则会报错</li><li>使用参数默认值时,函数不能有同名参数</li></ul><h2 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">console</span>.log(x, y);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span></code><br><code class="highlight javascript"><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span></code><br><code class="highlight javascript"><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span></code><br><code class="highlight javascript"><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span></code><br></pre></td></tr></table></figure><p>上面代码只使用了解构赋值默认值,并没有使用函数参数的默认值,所以函数不传参的情况下会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">console</span>.log(x, y);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">foo() <span class="comment">// undefined 5</span></span></code><br></pre></td></tr></table></figure><blockquote><p>函数的参数默认为一个空对象</p></blockquote><h2 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h2><p>制定了默认值以后,函数的length属性,将返回没有指定默认值的参数的个数, 即指定了默认值后,length属性将失真</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span></code><br><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span></code><br><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span></code><br></pre></td></tr></table></figure><blockquote><p>注意:</p><ul><li><p>rest参数也不会计入length属性<br><code>(function(...args) {}).length // 0</code></p></li><li><p>如果设置了默认值的参数不是尾参数,那么length属性也不再计入后面的参数了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span></code><br><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span></code><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">console</span>.log(y);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//调用函数f时,默认值指向的是第一个参数x,而不是全局变量x</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//即圆括号内形成一个单独的作用域</span></span></code><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p><p>即执行一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> mustBeProvided;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">foo()</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// Error: Missing parameter</span></span></code><br></pre></td></tr></table></figure><p>另外,可以将参数默认值设为undefined,表明这个参数是可以省略的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">optional = undefined</span>) </span>&#123; ··· &#125;</span></code><br></pre></td></tr></table></figure><h1 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h1><p>ES6引入rest参数(形式为 …变量名),用来获取函数的多余参数,这样就不需要使用arguments对象了</p><p>rest参数搭配的变量是一个数组,该变量将多余的参数放入数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span></code><br><code class="highlight javascript"><span class="line">    sum += val;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> sum;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span></code><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>rest参数之后不能再有其他参数(即只能是最后一个参数),否则会报错</li><li>函数的length属性,不包括rest参数</li></ul><h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>ES2016中规定,只要函数参数使用了默认值,解构赋值或者扩展运算符,那么函数内部就不能显示设定为严格模式,否则会报错</p><h1 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h1><p>函数的name属性,返回该函数的函数名.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span></code><br><code class="highlight javascript"><span class="line">foo.name <span class="comment">// "foo"</span></span></code><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>如果将一个匿名函数赋值给一个变量,会返回实际的函数名(变量名)</li><li>如果将一个具名函数赋值给一个变量,会返回这个具名函数原本的名字</li><li>Function构造函数返回的函数实例,name属性的值为anonymous</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// "anonymous"</span></span></code><br></pre></td></tr></table></figure><ul><li>bind返回的函数,name属性值上会加上bound前缀</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span></code><br><code class="highlight javascript"><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// "bound foo"</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// "bound "</span></span></code><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6允许使用”箭头”(<code>=&gt;</code>)自定义函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> v;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数,就是用一个圆括号代表参数部分</p><p>如果箭头函数的代码块部分只有一条语句且有返回值,则可以直接省略大括号,直接写返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> num1 + num2;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br></pre></td></tr></table></figure><p>如果箭头函数直接返回一个对象,必须在对象外面加上括号,否则会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 报错</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 不报错</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span></code><br></pre></td></tr></table></figure><p>如果箭头函数只有一行语句,且不需要返回值,可以采用下面的写法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> doesNotReturn();</span></code><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句,就要使用大括号括起来,并且使用return语句返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span></code><br></pre></td></tr></table></figure><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>箭头函数有几个使用注意点:</p><ul><li>函数体内的this对象,就是定义时所在的对象,而不是使用时所在的对象</li><li>不可以当作构造函数</li><li>不可以使用arguments对象,该对象在函数体内不存在, 可以使用rest参数代替</li><li>不可以使用yield命令,因此箭头函数不能用作Generator</li></ul><p>因为箭头函数内部没有自己的this,导致内部的this就是外层代码块的this</p><p>下面三个变量在箭头函数之中也是不存在的,指向外层函数的对应变量:</p><ul><li><code>arguments</code></li><li><code>super</code></li><li><code>new.target</code></li></ul><h2 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h2><p>一.定义对象的方法,且该方法内部包括this<br>因为对象不构成单独的作用域,所以对象内部的箭头函数的this会指向全局作用域</p><p>二.需要动态this的时候,也不应使用箭头函数</p><p>三.如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数， 而是要使用普通函数，这样可以提高代码可读性。</p><h2 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h2><p>箭头函数的内部,还可以再使用箭头函数</p><h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><p>尾调用就是值某个函数的最后一步是调用另一个函数</p><p>以下三种情况,都不属于尾调用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 情况一</span></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">let</span> y = g(x);</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> y;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 情况二</span></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 情况三</span></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  g(x);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//情况三等同于下面的代码:</span></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  g(x);</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br></pre></td></tr></table></figure><h2 id="尾调用优化-1"><a href="#尾调用优化-1" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>[严格模式下生效]<br>函数调用会在内存形成一个”调用记录”,又称为”调用帧”,保存调用位置和内部变量等信息.</p><p>如果在函数A的内部调用函数B,那么在A的调用帧上方,还会形成一个B的调用帧.等到B运行结束,将结果返回到A,B的调用帧才会消失,如果函数B内部还调用函数C,那就还有一个C的调用帧,以此类推.所有的调用帧就形成一个”调用栈”</p><p>尾调用由于是函数的最后一步操作,所以不需要保留外层函数的调用帧,因为调用位置,内部变量等信息都不会在用到了,只要直接用内层函数的调用帧,取代外层函数的调用帧就可以了.</p><p>“尾调用优化”,即只保留内层函数的调用帧,如果所有函数都是尾调用,那么完全可以做到每次执行时,调用帧只有一项,这将大大节省内存.</p><blockquote><p>注意:只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p></blockquote><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>[严格模式下生效]</p><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><p>递归非常消耗内存,因为需要同时保存成千上百个调用帧,很容易发生”栈溢出”错误(stack overflow)</p><p>但对于尾递归来说,由于只存在一个调用帧,所以永远不会发生”栈溢出”错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span></code><br></pre></td></tr></table></figure><h2 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h2><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。但是这样做的缺点就是不太直观,第一眼很难看出来</p><p><strong>解决方法一:</strong></p><p>在尾递归函数之外，再提供一个正常形式的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> tailFactorial(n, <span class="number">1</span>);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span></code><br></pre></td></tr></table></figure><p>函数式编程中 柯里化(currying) 的概念:</p><p>意思是将多参数的函数转换成单参数的形式</p><p><strong>解决方法二:</strong></p><p>采用ES6的函数默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span></code><br></pre></td></tr></table></figure><blockquote><p>总结: 递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现</p></blockquote><h2 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。<br>正常模式下,函数内部有两个变量,可以跟踪函数的调用栈</p><ul><li><code>func.arguments</code>:返回调用时函数的参数</li><li><code>func.caller</code>: 返回调用时当前函数的那个函数</li></ul><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restricted</span>(<span class="params"></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line"><span class="meta">  'use strict'</span>;</span></code><br><code class="highlight javascript"><span class="line">  restricted.caller;    <span class="comment">// 报错</span></span></code><br><code class="highlight javascript"><span class="line">  restricted.arguments; <span class="comment">// 报错</span></span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line">restricted();</span></code><br></pre></td></tr></table></figure><h2 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h2><p>在正常模式下实现尾递归优化</p><p>原理: 用“循环”换掉“递归”,减少调用栈</p><p><strong>方法一:</strong></p><p>蹦床函数(将递归执行转为循环执行)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">f</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">while</span> (f &amp;&amp; f <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span></code><br><code class="highlight javascript"><span class="line">    f = f();</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> f;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//接受一个函数f作为参数,只要f执行后返回一个函数,就继续执行,否则返回值</span></span></code><br></pre></td></tr></table></figure><p><strong>方法二:</strong></p><p>方法一的蹦床函数并非真正的尾递归优化</p><p>下面的才是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tco</span>(<span class="params">f</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">var</span> value;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">var</span> active = <span class="literal">false</span>;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">var</span> accumulated = [];</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">accumulator</span>(<span class="params"></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">    accumulated.push(<span class="built_in">arguments</span>);</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">if</span> (!active) &#123;</span></code><br><code class="highlight javascript"><span class="line">      active = <span class="literal">true</span>;</span></code><br><code class="highlight javascript"><span class="line">      <span class="keyword">while</span> (accumulated.length) &#123;</span></code><br><code class="highlight javascript"><span class="line">        value = f.apply(<span class="keyword">this</span>, accumulated.shift());</span></code><br><code class="highlight javascript"><span class="line">      &#125;</span></code><br><code class="highlight javascript"><span class="line">      active = <span class="literal">false</span>;</span></code><br><code class="highlight javascript"><span class="line">      <span class="keyword">return</span> value;</span></code><br><code class="highlight javascript"><span class="line">    &#125;</span></code><br><code class="highlight javascript"><span class="line">  &#125;;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> sum = tco(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>)</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">else</span> &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> x</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 100001</span></span></code><br></pre></td></tr></table></figure><p>上面的代码中,<code>tco</code>函数时尾递归优化的实现,它的奥妙就在于状态变量<code>active</code></p><h1 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h1><p>以前不允许最后一个参数后面出现逗号,这样对以后的修改很造成麻烦<br>ES2017 允许函数的最后一个参数有尾逗号</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.friendk.cn/%E5%89%8D%E7%AB%AF/Ecmascript6/6%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘凯"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="前端菜鸟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/%E5%89%8D%E7%AB%AF/Ecmascript6/6%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html" itemprop="url">ECMAScript6--函数的扩展</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-18T13:30:00+08:00">2019-10-18 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">前端学习</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/ECMAScript6/" itemprop="url" rel="index"><span itemprop="name">ECMAScript6</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">2.8k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">10</span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h1 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6允许为函数的参数设置默认值,即直接写在参数定义的后面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">console</span>.log(x, y);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span></code><br><code class="highlight javascript"><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span></code><br><code class="highlight javascript"><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span></code><br></pre></td></tr></table></figure><p>注意:</p><ul><li>参数变量是默认声明的,不能用<code>let</code>或<code>const</code>再次声明,否则会报错</li><li>使用参数默认值时,函数不能有同名参数</li></ul><h2 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">console</span>.log(x, y);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span></code><br><code class="highlight javascript"><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span></code><br><code class="highlight javascript"><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span></code><br><code class="highlight javascript"><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span></code><br></pre></td></tr></table></figure><p>上面代码只使用了解构赋值默认值,并没有使用函数参数的默认值,所以函数不传参的情况下会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">console</span>.log(x, y);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">foo() <span class="comment">// undefined 5</span></span></code><br></pre></td></tr></table></figure><blockquote><p>函数的参数默认为一个空对象</p></blockquote><h2 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h2><p>制定了默认值以后,函数的length属性,将返回没有指定默认值的参数的个数, 即指定了默认值后,length属性将失真</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span></code><br><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span></code><br><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span></code><br></pre></td></tr></table></figure><blockquote><p>注意:</p><ul><li><p>rest参数也不会计入length属性<br><code>(function(...args) {}).length // 0</code></p></li><li><p>如果设置了默认值的参数不是尾参数,那么length属性也不再计入后面的参数了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span></code><br><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span></code><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="built_in">console</span>.log(y);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//调用函数f时,默认值指向的是第一个参数x,而不是全局变量x</span></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//即圆括号内形成一个单独的作用域</span></span></code><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p><p>即执行一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> mustBeProvided;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">foo()</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// Error: Missing parameter</span></span></code><br></pre></td></tr></table></figure><p>另外,可以将参数默认值设为undefined,表明这个参数是可以省略的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">optional = undefined</span>) </span>&#123; ··· &#125;</span></code><br></pre></td></tr></table></figure><h1 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h1><p>ES6引入rest参数(形式为 …变量名),用来获取函数的多余参数,这样就不需要使用arguments对象了</p><p>rest参数搭配的变量是一个数组,该变量将多余的参数放入数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span></code><br><code class="highlight javascript"><span class="line">    sum += val;</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> sum;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span></code><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>rest参数之后不能再有其他参数(即只能是最后一个参数),否则会报错</li><li>函数的length属性,不包括rest参数</li></ul><h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>ES2016中规定,只要函数参数使用了默认值,解构赋值或者扩展运算符,那么函数内部就不能显示设定为严格模式,否则会报错</p><h1 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h1><p>函数的name属性,返回该函数的函数名.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span></code><br><code class="highlight javascript"><span class="line">foo.name <span class="comment">// "foo"</span></span></code><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>如果将一个匿名函数赋值给一个变量,会返回实际的函数名(变量名)</li><li>如果将一个具名函数赋值给一个变量,会返回这个具名函数原本的名字</li><li>Function构造函数返回的函数实例,name属性的值为anonymous</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// "anonymous"</span></span></code><br></pre></td></tr></table></figure><ul><li>bind返回的函数,name属性值上会加上bound前缀</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span></code><br><code class="highlight javascript"><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// "bound foo"</span></span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// "bound "</span></span></code><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6允许使用”箭头”(<code>=&gt;</code>)自定义函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> v;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数,就是用一个圆括号代表参数部分</p><p>如果箭头函数的代码块部分只有一条语句且有返回值,则可以直接省略大括号,直接写返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 等同于</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> num1 + num2;</span></code><br><code class="highlight javascript"><span class="line">&#125;;</span></code><br></pre></td></tr></table></figure><p>如果箭头函数直接返回一个对象,必须在对象外面加上括号,否则会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 报错</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 不报错</span></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span></code><br></pre></td></tr></table></figure><p>如果箭头函数只有一行语句,且不需要返回值,可以采用下面的写法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> doesNotReturn();</span></code><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句,就要使用大括号括起来,并且使用return语句返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span></code><br></pre></td></tr></table></figure><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>箭头函数有几个使用注意点:</p><ul><li>函数体内的this对象,就是定义时所在的对象,而不是使用时所在的对象</li><li>不可以当作构造函数</li><li>不可以使用arguments对象,该对象在函数体内不存在, 可以使用rest参数代替</li><li>不可以使用yield命令,因此箭头函数不能用作Generator</li></ul><p>因为箭头函数内部没有自己的this,导致内部的this就是外层代码块的this</p><p>下面三个变量在箭头函数之中也是不存在的,指向外层函数的对应变量:</p><ul><li><code>arguments</code></li><li><code>super</code></li><li><code>new.target</code></li></ul><h2 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h2><p>一.定义对象的方法,且该方法内部包括this<br>因为对象不构成单独的作用域,所以对象内部的箭头函数的this会指向全局作用域</p><p>二.需要动态this的时候,也不应使用箭头函数</p><p>三.如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数， 而是要使用普通函数，这样可以提高代码可读性。</p><h2 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h2><p>箭头函数的内部,还可以再使用箭头函数</p><h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><p>尾调用就是值某个函数的最后一步是调用另一个函数</p><p>以下三种情况,都不属于尾调用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="comment">// 情况一</span></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">let</span> y = g(x);</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> y;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 情况二</span></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 情况三</span></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  g(x);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//情况三等同于下面的代码:</span></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  g(x);</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br></pre></td></tr></table></figure><h2 id="尾调用优化-1"><a href="#尾调用优化-1" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>[严格模式下生效]<br>函数调用会在内存形成一个”调用记录”,又称为”调用帧”,保存调用位置和内部变量等信息.</p><p>如果在函数A的内部调用函数B,那么在A的调用帧上方,还会形成一个B的调用帧.等到B运行结束,将结果返回到A,B的调用帧才会消失,如果函数B内部还调用函数C,那就还有一个C的调用帧,以此类推.所有的调用帧就形成一个”调用栈”</p><p>尾调用由于是函数的最后一步操作,所以不需要保留外层函数的调用帧,因为调用位置,内部变量等信息都不会在用到了,只要直接用内层函数的调用帧,取代外层函数的调用帧就可以了.</p><p>“尾调用优化”,即只保留内层函数的调用帧,如果所有函数都是尾调用,那么完全可以做到每次执行时,调用帧只有一项,这将大大节省内存.</p><blockquote><p>注意:只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p></blockquote><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>[严格模式下生效]</p><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><p>递归非常消耗内存,因为需要同时保存成千上百个调用帧,很容易发生”栈溢出”错误(stack overflow)</p><p>但对于尾递归来说,由于只存在一个调用帧,所以永远不会发生”栈溢出”错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span></code><br></pre></td></tr></table></figure><h2 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h2><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。但是这样做的缺点就是不太直观,第一眼很难看出来</p><p><strong>解决方法一:</strong></p><p>在尾递归函数之外，再提供一个正常形式的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> tailFactorial(n, <span class="number">1</span>);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span></code><br></pre></td></tr></table></figure><p>函数式编程中 柯里化(currying) 的概念:</p><p>意思是将多参数的函数转换成单参数的形式</p><p><strong>解决方法二:</strong></p><p>采用ES6的函数默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span></code><br></pre></td></tr></table></figure><blockquote><p>总结: 递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现</p></blockquote><h2 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。<br>正常模式下,函数内部有两个变量,可以跟踪函数的调用栈</p><ul><li><code>func.arguments</code>:返回调用时函数的参数</li><li><code>func.caller</code>: 返回调用时当前函数的那个函数</li></ul><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restricted</span>(<span class="params"></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line"><span class="meta">  'use strict'</span>;</span></code><br><code class="highlight javascript"><span class="line">  restricted.caller;    <span class="comment">// 报错</span></span></code><br><code class="highlight javascript"><span class="line">  restricted.arguments; <span class="comment">// 报错</span></span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line">restricted();</span></code><br></pre></td></tr></table></figure><h2 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h2><p>在正常模式下实现尾递归优化</p><p>原理: 用“循环”换掉“递归”,减少调用栈</p><p><strong>方法一:</strong></p><p>蹦床函数(将递归执行转为循环执行)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">f</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">while</span> (f &amp;&amp; f <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span></code><br><code class="highlight javascript"><span class="line">    f = f();</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> f;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">//接受一个函数f作为参数,只要f执行后返回一个函数,就继续执行,否则返回值</span></span></code><br></pre></td></tr></table></figure><p><strong>方法二:</strong></p><p>方法一的蹦床函数并非真正的尾递归优化</p><p>下面的才是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="highlight javascript"><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tco</span>(<span class="params">f</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">var</span> value;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">var</span> active = <span class="literal">false</span>;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">var</span> accumulated = [];</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">accumulator</span>(<span class="params"></span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">    accumulated.push(<span class="built_in">arguments</span>);</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">if</span> (!active) &#123;</span></code><br><code class="highlight javascript"><span class="line">      active = <span class="literal">true</span>;</span></code><br><code class="highlight javascript"><span class="line">      <span class="keyword">while</span> (accumulated.length) &#123;</span></code><br><code class="highlight javascript"><span class="line">        value = f.apply(<span class="keyword">this</span>, accumulated.shift());</span></code><br><code class="highlight javascript"><span class="line">      &#125;</span></code><br><code class="highlight javascript"><span class="line">      active = <span class="literal">false</span>;</span></code><br><code class="highlight javascript"><span class="line">      <span class="keyword">return</span> value;</span></code><br><code class="highlight javascript"><span class="line">    &#125;</span></code><br><code class="highlight javascript"><span class="line">  &#125;;</span></code><br><code class="highlight javascript"><span class="line">&#125;</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line"><span class="keyword">var</span> sum = tco(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>)</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">  <span class="keyword">else</span> &#123;</span></code><br><code class="highlight javascript"><span class="line">    <span class="keyword">return</span> x</span></code><br><code class="highlight javascript"><span class="line">  &#125;</span></code><br><code class="highlight javascript"><span class="line">&#125;);</span></code><br><code class="highlight javascript"><span class="line"></span></code><br><code class="highlight javascript"><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span></code><br><code class="highlight javascript"><span class="line"><span class="comment">// 100001</span></span></code><br></pre></td></tr></table></figure><p>上面的代码中,<code>tco</code>函数时尾递归优化的实现,它的奥妙就在于状态变量<code>active</code></p><h1 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h1><p>以前不允许最后一个参数后面出现逗号,这样对以后的修改很造成麻烦<br>ES2017 允许函数的最后一个参数有尾逗号</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/15/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/17/">&gt;</a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="刘凯"><p class="site-author-name" itemprop="name">刘凯</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">96</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">35</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">32</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Tolerating" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:354378485@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_25405005" target="_blank" title="CSDN"><i class="fa fa-fw fa-contao"></i>CSDN</a> </span><span class="links-of-author-item"><a href="http://www.friendk.cn:8887/" target="_blank" title="微信"><i class="fa fa-fw fa-weixin"></i>微信</a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/19496491" target="_blank" title="bilibili"><i class="fa fa-fw fa-link"></i>bilibili</a></span></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">刘凯</span></div><div><a target="_blank" ref="nofollow" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33040202000618" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/images/gongan.png" style="float:left">浙公网安备 33040202000618号 </a>&nbsp;|&nbsp; <a href="http://www.miitbeian.gov.cn/" target="_blank" ref="nofollow">浙ICP备2020034976号-1</a></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user">本站访客数</i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人次 </span><span class="site-pv"><i class="fa fa-eye">本站总访问量</i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js"></script><script type="text/javascript" src="/js/src/motion.js"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script></body></html>